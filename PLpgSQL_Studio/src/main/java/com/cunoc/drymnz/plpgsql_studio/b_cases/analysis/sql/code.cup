package com.cunoc.drymnz.plpgsql_studio.b_cases.analysis.sql;

import java_cup.runtime.*;
import java.util.ArrayList;

import com.cunoc.drymnz.plpgsql_studio.a_entidades.analyzer.ErrorTypeInTheInterpreter;
import com.cunoc.drymnz.plpgsql_studio.a_entidades.analyzer.ReportErrorInterpreter;
import com.cunoc.drymnz.plpgsql_studio.a_entidades.analyzer.Token;
import com.cunoc.drymnz.plpgsql_studio.b_cases.analysis.InterpretSyntaticError;
import com.cunoc.drymnz.plpgsql_studio.a_entidades.analyzer.DataValue;
import com.cunoc.drymnz.plpgsql_studio.b_cases.analysis.AnalyzerSemantico;
import com.cunoc.drymnz.plpgsql_studio.a_entidades.analyzer.operations.ListTypeOperations;
import com.cunoc.drymnz.plpgsql_studio.a_entidades.analyzer.ListTypeData;
import com.cunoc.drymnz.plpgsql_studio.a_entidades.analyzer.operations.ListsDefaultFunctionOperations;


/**
     * ***STAR CODE*******
     */
    parser code {:

private ArrayList<ReportErrorInterpreter> listError = new ArrayList();
private LexemaSQL lexema;
private AnalyzerSemantico analyzerSemantico = new AnalyzerSemantico(); 

 ///
    private boolean mode = false;
    private String procedure = "";
    private int executionNumber = 0;
    private boolean exitProcedure = true;

        private ArrayList<String> listID = new ArrayList();
    ///

	  public ParserSQL(LexemaSQL Lexema) {
        super(Lexema);
        this.lexema = Lexema;
    }

    //erorr
    public void syntax_error(Symbol cur_token) {
        String nameTerminal = symbl_name_from_id(this.cur_token.sym);
        int numberTerminal = this.cur_token.sym;
        ///codigo para el objeto
        ErrorTypeInTheInterpreter type = ErrorTypeInTheInterpreter.SYNTACTIC;
        int line = cur_token.left+1;
        int columna = cur_token.right +1;
        String lexema = (this.cur_token.value!=null)? this.cur_token.value.toString() : "Token no existe";
        Token token =  new Token(line, columna, lexema);
        this.listError.add(new ReportErrorInterpreter(type, token, (new InterpretSyntaticError(this.stack)).descriptionParser(this)));
        System.out.println(this.listError.get(0).toString());
    }

    //Returnar el listado de errores
    public ArrayList<ReportErrorInterpreter> getListError() {
        return this.listError;
    }

    public AnalyzerSemantico getAnalyzerSemantico(){
        return this.analyzerSemantico;
    }

    private Token getToken(Symbol cur_token){
        int line = cur_token.left+1;
        int columna = cur_token.right +1;
        String lexema = (this.cur_token.value!=null)? this.cur_token.value.toString() : "Token no existe";
        return new Token(line, columna, lexema);
    }

    /**
     * ***END CODE*******
     */
:}

// Operadores l칩gicos
terminal AND_O, OR_O;
terminal PERIOD_AND_AS, OPEN_P, CLOSE_P,COMMA,EQUAL,ASTERISK,POINT;
/* OPERADORES */
//Operadores logicos
terminal SAME_AS,NOT_THE_SAME,LESS_THAN,LESS_THAN_EQUAL,GREATER_THAN,GREATER_THAN_EQUAL,OR,AND,NOT_O;
terminal SAME_AS_O;
//Operadores aritmetico
terminal ADDITION ,SUBTRACTION ,DIVISION ,MULTIPLICATION ;
//agrupacion
terminal PARENTHESIS_CLOSE,PARENTHESIS_OPEN;


/* Terminales */
terminal IDENTIFICADOR,DECIMAL_V,WHOLE,CHARS,TRUE,FALSE,ALIAS;

// DDL (Data Definition Language) - Definici칩n de Datos
terminal CONSTRAINT, REFERENCES, FOREIGN, PRIMARY;
terminal CREATE, SCHEMA, TABLE, ALTER, COLUMN;
terminal DROP, KEY, ADD, USE,MODIFY;

// Tipos de datos
terminal VARCHAR, INTEGER, BOOLEAN, INT,DECIMAL,DATE;

// DML (Data Manipulation Language) - Manipulaci칩n de Datos
terminal LEFT, JOIN, SELECT, INSERT, UPDATE;
terminal DELETE, VALUES, WHERE, FROM, INTO, SET;

// DCL (Data Control Language) - Control de Datos
terminal REVOKE, GRANT, USER;
terminal TO, ON;

// Restricciones y modificadores
terminal NOT, NULL,DEFAULT;
// PL/pgSQL - Declaraciones y Control
terminal DECLARE,BRACKETS_OPEN,BRACKETS_CLOSE;
terminal RAISE,NOTICE,WARNING,EXCEPTION;
terminal FOR,IN,LOOP,END;
terminal IF,THEN,ELSE;
/* No terminales */
//inicio
non terminal inicio,finalizacion_punto_y_coma;
non terminal varias_etiquetas_usar,etiqueta_inicial;
//SQLTestDDL
non terminal use_ddl;
non terminal atributos_tabla,type_attribute,type_privacy,various_attributes;
non terminal attribute_null;
non terminal accion_update,accion_fk;
non terminal space_use_alter,accion_alter;
///SQLTestDML
non terminal several_parameters,attribute_insert;
non terminal use_dml,insert_parameters,insert_value,logical_connector,continuation_UPDATE,logical_connector_loop;
non terminal identificador_loop,select_parameters,continuation_select,attribute_possibility;
non terminal optimization_loop,loop_set,possibility_alias;
non terminal type_optional_alter,optimization_where;
///SQL Test DCL
non terminal use_dcl;
non terminal optimization_create,option_grant,atributo_or_all;
non terminal identificador_or_point;
/*OPERACIONES*/
non terminal operaciones,parentesis,fucion_id,vacio_interno;
/*PL / PG SQL*/
non terminal start_pl_sql;
non terminal instrucciones;

// --- FUNCIONES ---
non terminal funcion;
non terminal ejecucion;
non terminal parametro_funcion;
non terminal bucle_parametros;
non terminal parametro;
non terminal bucle_funcione;

// --- DECLARACIONES ---
non terminal declaracion;
non terminal derivando_declaracion;
non terminal bucle_id;
non terminal tipos_datos;

// --- ASIGNACIONES ---
non terminal asignar_variable;
non terminal asignar;

// --- FUNCIONES POR DEFECTO ---
non terminal funciones_defecto;
non terminal bucle_insert,bucle_inicio;
non terminal datos_insert;

// --- SENTENCIAS DE CONTROL ---
non terminal sentencias_control;
non terminal realizar_operaciones;

// --- IF / ELSE ---
non terminal sentencia_if;
non terminal use_else;
non terminal sentencia_else;
non terminal sentencia_control_interno_if;
non terminal vacio_sentincia_interna;

/*************************************PRECEDENCIA******************************************************/
precedence left ADDITION, SUBTRACTION;
precedence left DIVISION, MULTIPLICATION;
precedence left SAME_AS_O, NOT_THE_SAME , LESS_THAN , LESS_THAN_EQUAL, GREATER_THAN , GREATER_THAN_EQUAL;
precedence left OR_O;
precedence left AND_O;
precedence left NOT_O;
precedence left OPEN_P,CLOSE_P;
/* Gram치tica */
start with inicio;
/**********************************************INICIO DE LA GRAMATICA******************************/
inicio ::= varias_etiquetas_usar
    |error varias_etiquetas_usar
    |/*epsilon*/
    ;
/**********************************************GRAMATICA DE ESTRUCTURA DE SQL******************************/

varias_etiquetas_usar::=
varias_etiquetas_usar etiqueta_inicial
| etiqueta_inicial
;

/**********************************************INICIO DE DDL,DML,DCL******************************/
etiqueta_inicial ::= use_ddl finalizacion_punto_y_coma
    |use_dml finalizacion_punto_y_coma
    |use_dcl finalizacion_punto_y_coma
    |start_pl_sql
    ; 

finalizacion_punto_y_coma ::= PERIOD_AND_AS
    | error
    ;
/************************************************ SQL DDL **************************************************/
use_ddl ::= CREATE optimization_create
    |USE SCHEMA IDENTIFICADOR
    |FOREIGN KEY OPEN_P IDENTIFICADOR CLOSE_P REFERENCES IDENTIFICADOR OPEN_P IDENTIFICADOR CLOSE_P accion_update
    |ALTER TABLE IDENTIFICADOR accion_alter space_use_alter IDENTIFICADOR type_optional_alter
    |DROP TABLE IDENTIFICADOR
    ;

optimization_create ::= TABLE IDENTIFICADOR OPEN_P various_attributes CLOSE_P
    |SCHEMA IDENTIFICADOR
    |USER IDENTIFICADOR
    ;
// ATRIBUTO DE LA TABLA
various_attributes ::= various_attributes COMMA atributos_tabla
    |atributos_tabla 
    ; 

atributos_tabla ::= IDENTIFICADOR type_attribute type_privacy
    |FOREIGN KEY OPEN_P IDENTIFICADOR CLOSE_P REFERENCES IDENTIFICADOR OPEN_P IDENTIFICADOR CLOSE_P
    ;

accion_update ::= /*epsilon*/
    | ON UPDATE accion_fk
    | ON DELETE accion_fk
    ;

accion_fk ::= SET 
    ;

type_privacy ::= PRIMARY KEY attribute_null
    |attribute_null
    |NULL
    |DEFAULT
    ;

attribute_null ::=    NOT NULL 
    |error
    | /*epsilon*/
    ;

// ATRIBUTO DE LA TABLA

/* alter_use::= 
    //| CHECK 
    //| UNIQUE 
    ; */

// FORMA ALTER
type_optional_alter ::= /*epsilon*/
    |type_attribute
    |FOREIGN KEY OPEN_P IDENTIFICADOR CLOSE_P REFERENCES IDENTIFICADOR OPEN_P IDENTIFICADOR CLOSE_P accion_update 
    ;

accion_alter ::= ADD
    |DROP
    |MODIFY
    ;

space_use_alter ::= CONSTRAINT
    |COLUMN
    ;

/************************************************ SQL DML **************************************************/
use_dml ::= INSERT INTO select_parameters OPEN_P several_parameters CLOSE_P VALUES OPEN_P insert_parameters  CLOSE_P 
    |UPDATE select_parameters SET loop_set  WHERE IDENTIFICADOR EQUAL insert_value continuation_UPDATE
    |DELETE FROM select_parameters WHERE IDENTIFICADOR EQUAL insert_value continuation_UPDATE 
    |SELECT select_parameters FROM select_parameters continuation_select
    ;

continuation_select ::= 
    |WHERE optimization_where
    |JOIN select_parameters possibility_alias ON select_parameters possibility_alias EQUAL select_parameters continuation_select
    |ALIAS continuation_select
    |LEFT JOIN select_parameters possibility_alias ON select_parameters EQUAL select_parameters
    ;

optimization_where ::= 
     logical_connector_loop
    |select_parameters EQUAL insert_value continuation_UPDATE
    ;

loop_set ::= loop_set COMMA IDENTIFICADOR EQUAL insert_value
    |IDENTIFICADOR EQUAL insert_value
    ;

possibility_alias ::= 
    |ALIAS
    |IDENTIFICADOR
    ;

select_parameters ::= identificador_loop     ;

identificador_loop ::= identificador_loop COMMA optimization_loop
    |optimization_loop
    ;

optimization_loop ::=IDENTIFICADOR attribute_possibility 
    |ALIAS attribute_possibility
    |ASTERISK
    ;

attribute_possibility ::= POINT IDENTIFICADOR 
    | /*epsilon*/
    ;

continuation_UPDATE ::= 
    |logical_connector_loop
    ;

logical_connector ::= AND select_parameters EQUAL insert_value
    |OR select_parameters EQUAL insert_value
    ;

logical_connector_loop ::= logical_connector_loop logical_connector
    | logical_connector
    ;

insert_parameters ::= insert_parameters COMMA insert_value
    |insert_value
    ;

insert_value ::= operaciones
    |NULL
    |DEFAULT
    |error
    ;

several_parameters::= several_parameters COMMA attribute_insert
    |attribute_insert
    ;

attribute_insert::= 
    operaciones
    |
    |error
    ;
/************************************************ SQL DCL **************************************************/
use_dcl ::= GRANT option_grant ON identificador_or_point TO IDENTIFICADOR
    | REVOKE option_grant ON identificador_or_point FROM IDENTIFICADOR
    ;

identificador_or_point ::= IDENTIFICADOR POINT atributo_or_all
    |IDENTIFICADOR
    ;

option_grant ::= INSERT
    |SELECT
    |UPDATE
    |DELETE
    |REFERENCES
    ;

atributo_or_all ::= ASTERISK
    |IDENTIFICADOR
    ;

/**********************************************ESTRUCTURA DE LA OPERACIONES******************************/
operaciones::= 
// ==
 operaciones:leftString SAME_AS_O            operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
            RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.SAME_AS,getToken(this.parser.cur_token));
          } else {
            RESULT = null;
          }
:}
 //!=
|operaciones:leftString NOT_THE_SAME       operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.NOT_THE_SAME,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}

//<
|operaciones:leftString LESS_THAN          operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.LESS_THAN,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}

//<=
|operaciones:leftString LESS_THAN_EQUAL    operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.LESS_THAN_EQUAL,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}

//>
|operaciones:leftString GREATER_THAN       operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.GREATER_THAN,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}

//>=
|operaciones:leftString GREATER_THAN_EQUAL operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.GREATER_THAN_EQUAL,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}

//||
|operaciones:leftString OR_O                 operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.OR,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}

//&&
|operaciones:leftString AND_O                operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.AND,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}
//! 
|NOT_O operaciones:rightString 
{:
 if (rightString != null) {
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(null, rightDataValue,ListTypeOperations.NOT,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}
//+
|operaciones:leftString ADDITION           operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.ADDITION,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}
//-
///OPERACION DE REATA
|operaciones:leftString SUBTRACTION        operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.SUBTRACTION,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}
// /
|operaciones:leftString DIVISION           operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.DIVISION,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
          :}// *
|operaciones:leftString MULTIPLICATION     operaciones:rightString
{:
 if (leftString != null && rightString != null) {
            DataValue leftDataValue = (DataValue) leftString;
            DataValue rightDataValue = (DataValue) rightString;
RESULT = analyzerSemantico.operationsDatas(leftDataValue, rightDataValue,ListTypeOperations.MULTIPLICATION,getToken(this.parser.cur_token));
} else {
            RESULT = null;
          }
:}
// ( *** )
|PARENTHESIS_OPEN operaciones:a PARENTHESIS_CLOSE {:RESULT = a;:}
//Datos
//|TEXT:a {:RESULT = new DataValue(a.toString(),ListTypeData.STRING);:}
|TRUE:a {:RESULT = new DataValue(a.toString(),ListTypeData.BOOLEAN);:}
|FALSE:a {:RESULT = new DataValue(a.toString(),ListTypeData.BOOLEAN);:}
|DECIMAL_V:a {:RESULT = new DataValue(a.toString(),ListTypeData.DECIMAL);:}
|WHOLE:a {:RESULT = new DataValue(a.toString(),ListTypeData.INTEGER);:}
|SUBTRACTION DECIMAL_V:a {:RESULT = new DataValue("-"+a.toString(),ListTypeData.DECIMAL);:}
|SUBTRACTION WHOLE:a {:RESULT = new DataValue("-"+a.toString(),ListTypeData.INTEGER);:}
|CHARS:a {:RESULT = new DataValue(a.toString(),ListTypeData.CHAR);:}
|parentesis:a {:RESULT = a;:}
|funciones_defecto:a {:RESULT = a;:}
//{:RESULT = a;:}
; 

parentesis ::= 
IDENTIFICADOR:id fucion_id:funcion_id  
//Con este emetodo return el valor del dato para operacion.
{:RESULT = analyzerSemantico.retrieveDataVariableOrFunction(id.toString(),getToken(this.parser.cur_token));:};

fucion_id::= OPEN_P vacio_interno:a {:RESULT = a;:}
|{:RESULT = null;:}
;

vacio_interno::= operaciones:a OPEN_P 
{:RESULT = a;:}
|CLOSE_P 
{:RESULT = null;:}
;

/************************************************ PL/pgSQL **************************************************/
start_pl_sql ::=instrucciones;

type_attribute ::= INTEGER
    | BOOLEAN
    | INT
    | VARCHAR OPEN_P operaciones CLOSE_P
    | DECIMAL
    | DATE
    ;
instrucciones::= 
funcion
| DECLARE declaracion
| asignar_variable
| sentencias_control
| funciones_defecto PERIOD_AND_AS
;

//  FUNCTION_calc(               )                     [           ]
funcion::= IDENTIFICADOR:id PARENTHESIS_OPEN parametro_funcion ejecucion 
{:
RESULT = id;
String userIde = id.toString();
analyzerSemantico.registerVariable(userIde,new DataValue(userIde, ListTypeData.VOID),getToken(this.parser.cur_token),mode,procedure,executionNumber);
if(exitProcedure){
  procedure = userIde;
  exitProcedure = false;
}
:}
; 

ejecucion::= BRACKETS_OPEN  bucle_funcione:bu   
|PERIOD_AND_AS 
;

parametro_funcion::= PARENTHESIS_CLOSE
|bucle_parametros PARENTHESIS_CLOSE
;

bucle_parametros::= bucle_parametros COMMA parametro
|parametro
;

parametro::= tipos_datos IDENTIFICADOR;

bucle_funcione::= BRACKETS_CLOSE
{:
if(!exitProcedure){
  exitProcedure = true;
  procedure= "main";
}
:}
|bucle_inicio BRACKETS_CLOSE
{:
if(!exitProcedure ){
  exitProcedure = true;
  procedure= "main";
}
:}
;

// DECLARACION
declaracion::= derivando_declaracion tipos_datos:type  asignar:valorUsar 
{:
if(type!=null){
    ListTypeData typeData = (ListTypeData) type;
    DataValue data = (valorUsar!=null)? (DataValue) valorUsar : new DataValue("", typeData);
    analyzerSemantico.registerVariables(listID,data,getToken(this.parser.cur_token),mode,procedure,executionNumber);
    mode = false;
}
listID = new ArrayList();	
:}
; 

derivando_declaracion ::= bucle_id;

bucle_id ::= bucle_id COMMA IDENTIFICADOR:a
{:listID.add(a.toString());:}
|IDENTIFICADOR:a
{:listID.add(a.toString());:}
;

tipos_datos ::= 
INTEGER 
{:RESULT = ListTypeData.INTEGER;:}
|DECIMAL 
{:RESULT = ListTypeData.DECIMAL;:}
|BOOLEAN 
{:RESULT = ListTypeData.BOOLEAN;:}
|VARCHAR OPEN_P operaciones CLOSE_P
{:RESULT = ListTypeData.CHAR;:}
|INT
{:RESULT = ListTypeData.INTEGER;:}
|DATE
{:RESULT = ListTypeData.DATE;:}
; 

// DECLARACION ASIGNACION
asignar_variable::= IDENTIFICADOR:id EQUAL operaciones:dope PERIOD_AND_AS 
{:
if(id != null && dope != null){
DataValue dopeDataValue = (DataValue) dope;
analyzerSemantico.assignNewData(id.toString(),dopeDataValue,getToken(this.parser.cur_token));
}
:}
; 

asignar::=  PERIOD_AND_AS
{:RESULT = null;:}
|EQUAL operaciones:a PERIOD_AND_AS  
{:RESULT = a;:}
; 

// Funciones por defecto
funciones_defecto::= 
RAISE   NOTICE operaciones:parametro
{:
if(parametro!=null){
DataValue parametroDataValue = (DataValue) parametro;
RESULT = analyzerSemantico.getFunctionResult(parametroDataValue, ListsDefaultFunctionOperations.ALERT_INFO,getToken(this.parser.cur_token));
}
:}
;

bucle_insert ::= bucle_insert COMMA datos_insert
|datos_insert
;

datos_insert::= IDENTIFICADOR
|WHOLE
|DECIMAL
|CHARS
;
// SENTENCIAS DE CONTROL
sentencias_control::= 
// if 
sentencia_if
// FOR
|FOR ALIAS   IN operaciones POINT POINT operaciones LOOP operaciones  sentencia_control_interno_if
;

/// SENTENCIA DE IF
sentencia_if::= 
IF realizar_operaciones THEN sentencia_control_interno_if:end
{: analyzerSemantico.andIf(true);:}
|use_else sentencia_else
{: analyzerSemantico.andIf(true);:}
;

use_else::= ELSE
{: analyzerSemantico.andIf(!analyzerSemantico.getIf_instruc());:}

; 

realizar_operaciones::= PARENTHESIS_OPEN   operaciones:leftString  PARENTHESIS_CLOSE
{:
 if (leftString != null && leftString instanceof DataValue) {
            DataValue operation = (DataValue) leftString;
            RESULT = operation ;
            analyzerSemantico.ifOperation(operation, getToken(this.parser.cur_token));
          } else {
            RESULT = null;
          }
:}
;

sentencia_else::=  vacio_sentincia_interna 
|instrucciones:end
;

sentencia_control_interno_if::= instrucciones:end END LOOP
{:RESULT = false;:}
;

vacio_sentincia_interna ::= bucle_inicio END 
{:RESULT = false;:}
|END
{:RESULT = false;:}
;

